---
generated: 2026-01-17
skill: manual-analysis
sources:
  - https://github.com/frankbria/ralph-claude-code (accessed 2026-01-17)
  - ralph.md (modified 2026-01-17)
  - .claude/rules/system/session-state-protocol.md
  - nexa/state.json
  - .claude/commands/README.md
temperature: warm
review_by: 2026-02-17
---

# Ralph-Claude-Code Comparison Analysis

## Executive Summary

PM OS has **already implemented 60-70% of Ralph-style concepts**, particularly around session state, progress tracking, and resume capabilities. The **biggest gaps** are:

1. **No CLI front door** - PM OS uses Claude Code skills/commands, not a dedicated CLI
2. **No bounded loops** - No circuit breaker or exit detection for long-running tasks
3. **No monitoring dashboard** - No real-time status visibility

**Recommendation:** Implement **#1 (status/resume front door)** and **#2 (progress ledger)** from engineering feedback - both high ROI, low effort.

---

## Concept-by-Concept Comparison

| Ralph Concept | PM OS Equivalent | Status | Gap Analysis |
|---------------|------------------|--------|--------------|
| **Session management with persistence** | `nexa/state.json` + session-state-protocol.md | ‚úÖ **Implemented** | PM OS tracks: skill, phase, step, sources, decisions, blockers |
| **Resume capability** | Session start protocol checks nexa/state.json, offers resume | ‚úÖ **Implemented** | "Continue from where you left off or start fresh?" |
| **Progress tracking** | Session state Progress table + History with date suffixes | ‚úÖ **Implemented** | Tracks step status, notes per session |
| **Staleness detection** | `nexa/state.json` with dependency graph | ‚úÖ **Implemented** | Auto-detects when sources change, flags stale outputs |
| **Exit detection** | Goal-backward verification, deviation rules | ‚ö†Ô∏è **Partial** | No dual-condition gates, no EXIT_SIGNAL pattern |
| **Circuit breaker / rate limiting** | *(none)* | ‚ùå **Not implemented** | No protection against stuck loops or API limits |
| **CLI commands** | `.claude/commands/*.md` (11 commands) | ‚úÖ **Implemented** | `/ktlo`, `/voc`, `/charters`, etc. - but via Claude Code, not standalone CLI |
| **Status command** | *(none)* | ‚ùå **Not implemented** | No `status` command to show "what's hot + what's blocked" |
| **Progress ledger (append-only)** | Session state tracks decisions, but not append-only log | ‚ö†Ô∏è **Partial** | Session state is overwritten, not appended |
| **File hierarchy with control files** | Skills in `skills/`, commands in `.claude/commands/` | ‚úÖ **Implemented** | Different structure (no @ prefix), but similar pattern |
| **Response analyzer** | *(none)* | ‚ùå **Not implemented** | No semantic analysis of Claude responses for errors |
| **Monitoring dashboard** | *(none)* | ‚ùå **Not implemented** | No tmux/TUI dashboard for real-time status |
| **PRD import system** | Manual file drop into `inputs/` | ‚ö†Ô∏è **Partial** | No automatic conversion from PDF/DOCX/JSON |
| **5-hour API limit handling** | *(none)* | ‚ùå **Not implemented** | No explicit handling of Claude usage ceiling |
| **Modern CLI integration** | Via Claude Code Skill tool | ‚úÖ **Different approach** | PM OS integrates via Claude Code, not standalone CLI |
| **Dual-condition completion** | Goal-backward verification | ‚ö†Ô∏è **Partial** | Verifies completion, but no dual-gate pattern |
| **Temperature classification** | `temperature: hot/warm/cold` in output metadata | ‚úÖ **Implemented** | Similar concept for review cadence |
| **Learning system** | `pm-os learn <skill>` mines patterns | ‚úÖ **Implemented** | Extracts patterns from history, writes to `.claude/rules/learned/` |

---

## What PM OS Has That Ralph Doesn't

| PM OS Feature | Description | Ralph Equivalent |
|---------------|-------------|------------------|
| **Evidence discipline** | Claims ledger, source attribution, Evidence/Assumption/Open Question tags | *(none)* |
| **Modular rules architecture** | `.claude/rules/` auto-discovery with precedence (system ‚Üí pm-core ‚Üí domain ‚Üí pm-workflows ‚Üí learned) | *(none - rules are in PROMPT.md)* |
| **Domain vocabulary** | `.claude/rules/domain/vocabulary.md` for Business Network + Catalogs | *(none)* |
| **Tier-based dependency graph** | Tier 0 (context) ‚Üí Tier 1 (insights) ‚Üí Tier 2 (charters) ‚Üí Tier 3 (PRDs) | *(basic file dependencies only)* |
| **Deviation rules** | 4-rule protocol for missing files, conflicts, scope creep, broken assumptions | *(none)* |
| **Related files protocol** | Cascade rules to keep related files in sync | *(none)* |
| **Goal-backward verification** | "Does this output achieve its purpose?" checks | *(none)* |
| **Output metadata standards** | YAML frontmatter with sources, downstream, temperature | *(basic metadata only)* |
| **Senior PM coverage** | Stakeholders, GTM, strategy, reviews beyond core PM workflows | *(Ralph is dev-focused, not PM-focused)* |
| **History-based learning** | Mines `history/` for success/failure patterns, auto-generates rules | *(progress logs, but no pattern extraction)* |
| **Output styles** | Configurable communication styles via `.claude/output-styles/` | *(none)* |

---

## Engineering Recommendations Evaluation

From `ralph.md`, engineer recommended 4 Ralph-style additions. Here's how they map to PM OS:

### 1. `start / resume / status` Front Door (Value 9, Effort 3)

**Recommendation:** `nexa start <initiative>` + `nexa status` that surfaces: phase, next actions, blockers, review_by

**PM OS Status:**
- ‚úÖ **Resume capability exists** - Session state protocol checks `nexa/state.json`, offers resume
- ‚ùå **No `status` command** - No quick way to show "what's hot + what's blocked"
- ‚ùå **No `start <initiative>` command** - No CLI to route to specific initiative

**Gap:**
PM OS has the *backend* (session state, temperature classification) but lacks the *front door* (CLI commands to surface it).

**Implementation Path:**
1. Add `status` command to `.claude/commands/status.md`
2. Status command reads:
   - `nexa/state.json` (current activity, blockers)
   - All outputs with `temperature: hot` (what's active)
   - `nexa/state.json` (what needs refresh)
3. Format output as:
   ```
   üìç Current Session: [skill] at [phase]
   üî• Hot Outputs: [list with review_by dates]
   ‚ö†Ô∏è Stale: [list stale outputs]
   üöß Blockers: [list blockers]
   ```

**Effort:** Low (3/10) - infrastructure exists, just needs command wrapper

**Value:** High (9/10) - biggest daily efficiency win

**Recommendation:** ‚úÖ **Implement this** - high ROI, low effort

---

### 2. Progress Ledger (Append-Only) (Value 7, Effort 2)

**Recommendation:** `outputs/initiatives/<id>/progress.md` (append notes per "iteration/day")

**PM OS Status:**
- ‚ö†Ô∏è **Partial** - Session state exists but is *overwritten* not *appended*
- ‚úÖ **History with dates** - `history/<skill>/<output>-YYYY-MM-DD.md` tracks versions over time

**Gap:**
PM OS uses history *files* (one per run) instead of an *append-only log* (one file, many entries).

**Tradeoff Analysis:**

| Approach | Pros | Cons |
|----------|------|------|
| **Ralph: Append-only progress.md** | Single file to scan, easy to see evolution | Can get large, harder to query specific dates |
| **PM OS: Dated history files** | Easy to compare specific versions, Git-friendly | Need to read multiple files to see evolution |

**Current PM OS approach is valid** - it achieves the same goal (persist learnings over time) with a different structure.

**Enhancement Option:**
Add a `progress-ledger.md` *in addition to* dated history files for daily notes:

```markdown
## 2026-01-17
- Started charters for Q1
- Discovered VOC synthesis missing - ran synthesizing-voc first
- Blocker: Need truth base before proceeding

## 2026-01-18
- Completed truth base
- Resumed charters, now at Step 3 of 5
```

**Effort:** Very Low (2/10) - just create append-only file + update convention

**Value:** Medium-High (7/10) - makes daily updates painless

**Recommendation:** ‚úÖ **Implement this** - high ROI, very low effort

**Implementation:**
- Create `outputs/initiatives/<initiative-name>/progress.md`
- Update session-state-protocol.md to append daily notes
- Keep dated history files for version comparison

---

### 3. Bounded Loops for Mechanical Batching (Value 8/4, Effort 6)

**Recommendation:** `nexa loop inbox` / `nexa loop jira` with max-iterations + hard stop signals

**PM OS Status:**
- ‚ùå **Not implemented** - No circuit breaker, no loop protection
- ‚ö†Ô∏è **Skills run once** - Not designed for multi-iteration loops

**Gap:**
PM OS skills are *single-shot* (run once, generate output). Ralph loops are *iterative* (run until done or max-iterations).

**Use Case Analysis:**

| Task | Needs Loops? | PM OS Approach |
|------|-------------|----------------|
| Triage 100 Jira tickets | Maybe | `/ktlo` reads all tickets in one pass |
| Daily inbox digestion | Yes | Could benefit from "process 10 at a time" loop |
| Competitive analysis | No | One-shot skill works fine |
| Weekly planning | No | One-shot skill works fine |

**Value depends on batching pain:**
- **High (8/10)** if you regularly batch process (Jira grooming, inbox, competitive digests)
- **Low (4/10)** if you don't have recurring batching tasks

**Effort:** High (6/10) - needs circuit breaker, max iterations, exit detection, safety rules

**Recommendation:** ‚ö†Ô∏è **Conditional** - only if you have recurring batching pain

**Not a priority** unless you find yourself running `/ktlo` 10 times per day on small batches.

---

### 4. Monitor / Dashboard UX (Value 4, Effort 6)

**Recommendation:** TUI or monitor output; JSON status for scripts

**PM OS Status:**
- ‚ùå **Not implemented** - No dashboard, no JSON output
- ‚úÖ **Files are queryable** - Can script against `outputs/`, `nexa/state.json`, `nexa/state.json`

**Gap:**
PM OS uses *files as the interface*. Ralph uses *dashboard as the interface*.

**Tradeoff:**
- **Ralph dashboard:** Visual, real-time, good for long loops
- **PM OS files:** Scriptable, Git-friendly, works with existing tools (grep, jq, etc.)

**Value:** Low (4/10) - nice, but mostly useful if you run long loops

**Effort:** High (6/10) - requires TUI library, real-time updates, JSON formatting

**Recommendation:** ‚ùå **Skip for now** - low ROI, high effort

Only implement if you add bounded loops (#3) first.

---

## Key Architectural Differences

| Dimension | Ralph | PM OS |
|-----------|-------|-------|
| **Primary Use Case** | Autonomous development loops | Evidence-based PM workflows |
| **Execution Model** | Iterative (cycle until done) | Single-shot (run once per skill) |
| **Interface** | Standalone CLI (`ralph`, `ralph-monitor`) | Claude Code integration (Skill tool, commands) |
| **State Persistence** | `progress.txt`, PRD state files | `nexa/state.json`, dated history files |
| **Exit Detection** | Dual-condition (heuristics + EXIT_SIGNAL) | Goal-backward verification (after completion) |
| **Safety** | Circuit breaker, rate limiter, 5-hour handling | Deviation rules, staleness protocol |
| **Monitoring** | tmux dashboard, JSON output | File-based (nexa/state.json) |
| **Learning** | Implicit (via progress logs) | Explicit (`pm-os learn <skill>` mines patterns) |

**PM OS is optimized for PM workflows** (evidence discipline, dependency tracking, learning).

**Ralph is optimized for dev workflows** (autonomous loops, safety guards, monitoring).

---

## Recommendations (Prioritized)

### Priority 1: Implement Status Front Door (High ROI, Low Effort)

**What to build:**
1. Add `/status` command to `.claude/commands/status.md`
2. Status command outputs:
   - Current session activity (from `nexa/state.json`)
   - Hot outputs (temperature: hot with review_by dates)
   - Stale outputs (from `nexa/state.json`)
   - Blockers (from session state)

**Why:** Biggest daily efficiency win. Reduces "where do I look?" moments.

**Effort:** 3/10 (infrastructure exists, just needs command)

**Value:** 9/10

---

### Priority 2: Add Progress Ledger (High ROI, Very Low Effort)

**What to build:**
1. Create `outputs/initiatives/<initiative-name>/progress.md`
2. Update session-state-protocol.md to append daily notes
3. Keep dated history files for version comparison

**Format:**
```markdown
## YYYY-MM-DD
- [Notes from this session]
- [Decisions made]
- [Blockers hit]
```

**Why:** Makes daily updates painless. Matches Ralph pattern of persisting learnings.

**Effort:** 2/10

**Value:** 7/10

---

### Priority 3: Consider Bounded Loops (Conditional)

**When to implement:**
- You run `/ktlo` 10+ times per day on small batches
- You have recurring batching pain (Jira grooming, inbox digestion, competitive digests)

**What to build:**
1. Loop wrapper skill with max-iterations parameter
2. Circuit breaker (error detection, max API calls)
3. Exit detection (completion signals, explicit STOP)

**Effort:** 6/10

**Value:** 8/10 (if batching pain exists) / 4/10 (if not)

**Current recommendation:** ‚ö†Ô∏è **Wait** - not urgent unless batching pain surfaces

---

### Priority 4: Skip Dashboard for Now

**Reasoning:**
- Low value (4/10) unless you implement bounded loops
- High effort (6/10)
- File-based interface works well for current PM workflows

**Revisit if:** You implement bounded loops and need real-time monitoring

---

## Claims Ledger

| Claim | Type | Source |
|-------|------|--------|
| PM OS has implemented 60-70% of Ralph concepts | Assumption | Concept-by-concept comparison above (14/20 concepts fully or partially implemented) |
| Session state protocol exists in PM OS | Evidence | `.claude/rules/system/session-state-protocol.md`, `nexa/state.json` |
| Resume capability exists in PM OS | Evidence | session-state-protocol.md:25-35 (session resume protocol) |
| No CLI front door in PM OS | Evidence | No `status` command found in `.claude/commands/` (ls shows 11 commands, none named "status") |
| No circuit breaker in PM OS | Evidence | Grep for "circuit breaker" in .claude/rules/ returns no results |
| Ralph uses dual-condition exit gates | Evidence | GitHub WebFetch: "Dual-condition check requiring BOTH completion indicators AND explicit EXIT_SIGNAL" |
| Status front door has Value 9, Effort 3 | Evidence | ralph.md:15 (table row 1) |
| Progress ledger has Value 7, Effort 2 | Evidence | ralph.md:16 (table row 2) |
| Bounded loops have Value 8/4, Effort 6 | Evidence | ralph.md:17 (table row 3) |
| Dashboard has Value 4, Effort 6 | Evidence | ralph.md:18 (table row 4) |

---

## Sources Used

1. https://github.com/frankbria/ralph-claude-code (accessed 2026-01-17) - Ralph architecture, features, design patterns
2. ralph.md (engineering feedback) - Value/effort analysis for Ralph-style additions
3. .claude/rules/system/session-state-protocol.md - PM OS session management
4. nexa/state.json - Current session state structure
5. .claude/commands/README.md - PM OS command system
6. nexa/state.json - Staleness tracking
7. .claude/rules/pm-core/goal-backward-verification.md - Completion verification
8. .claude/rules/pm-core/deviation-rules.md - Error handling

---

## Next Actions

| Action | Owner | Timeline |
|--------|-------|----------|
| Implement `/status` command | TBD | Week of 2026-01-20 |
| Add progress ledger convention | TBD | Week of 2026-01-20 |
| Document status command usage in README | TBD | After status implemented |
| Monitor for batching pain (decide on bounded loops) | TBD | Ongoing |

---

## Open Questions

1. **Initiative-level state:** Should we create `outputs/initiatives/<name>/STATE.md` distinct from session state? (Session = ephemeral "what am I doing now", Initiative = persistent "where is this overall")
2. **CLI abstraction:** Should PM OS build a standalone CLI (`pmos status`) or continue using Claude Code commands?
3. **Append-only vs dated files:** Keep both or choose one for progress tracking?
4. **Circuit breaker threshold:** If implementing bounded loops, what's reasonable max-iterations? (Ralph uses 100 API calls/hour)

---

*This analysis compares ralph-claude-code concepts with PM OS implementation. Recommendation: implement status front door (#1) and progress ledger (#2) for high ROI, low effort wins.*
